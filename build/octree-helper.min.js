/**
 * octree-helper v1.1.1 build Sat Feb 01 2020
 * https://github.com/vanruesc/octree-helper
 * Copyright 2020 Raoul van Rüschen
 * @license Zlib
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e=e||self).OCTREEHELPER={},e.THREE)}(this,(function(e,t){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function o(e){return(o=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function i(e,t){return(i=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function a(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}
/**
   * sparse-octree v6.0.2 build Sat Jan 18 2020
   * https://github.com/vanruesc/sparse-octree
   * Copyright 2020 Raoul van Rüschen
   * @license Zlib
   */var u=[new Uint8Array([0,4]),new Uint8Array([1,5]),new Uint8Array([2,6]),new Uint8Array([3,7]),new Uint8Array([0,2]),new Uint8Array([1,3]),new Uint8Array([4,6]),new Uint8Array([5,7]),new Uint8Array([0,1]),new Uint8Array([2,3]),new Uint8Array([4,5]),new Uint8Array([6,7])],f=[new Uint8Array([0,0,0]),new Uint8Array([0,0,1]),new Uint8Array([0,1,0]),new Uint8Array([0,1,1]),new Uint8Array([1,0,0]),new Uint8Array([1,0,1]),new Uint8Array([1,1,0]),new Uint8Array([1,1,1])],c=function(e){function c(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return r(this,c),(e=a(this,o(c).call(this))).name="OctreeHelper",e.octree=t,e.update(),e}var s,l,y;return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&i(e,t)}(c,e),s=c,(l=[{key:"createLineSegments",value:function(e,r){var n,o,i,a,c,s,l,y,p,w,h,d,A,b,U,v,m=Math.pow(2,16)/8-1,g=new t.Group,O=new t.LineBasicMaterial({color:16777215*Math.random()});for(w=0,i=0,b=Math.ceil(r/m);b>0;--b){for(i+=r<m?r:m,r-=m,o=8*i,a=new Uint16Array(3*o),c=new Float32Array(3*o),d=0,A=0,n=e.next();!n.done&&w<i;){for(l=(s=n.value).min,y=s.max,h=0;h<12;++h)v=u[h],a[A++]=d+v[0],a[A++]=d+v[1];for(h=0;h<8;++h,++d)U=f[h],c[3*d]=0===U[0]?l.x:y.x,c[3*d+1]=0===U[1]?l.y:y.y,c[3*d+2]=0===U[2]?l.z:y.z;++w<i&&(n=e.next())}(p=new t.BufferGeometry).setIndex(new t.BufferAttribute(a,1)),p.setAttribute("position",new t.BufferAttribute(c,3)),g.add(new t.LineSegments(p,O))}this.add(g)}},{key:"update",value:function(){var e,t=null!==this.octree?this.octree.getDepth():-1,r=0;for(this.dispose();r<=t;)e=this.octree.findNodesByLevel(r),this.createLineSegments(e[Symbol.iterator](),"number"==typeof e.size?e.size:e.length),++r}},{key:"dispose",value:function(){var e,t,r,n,o,i,a=this.children;for(r=0,o=a.length;r<o;++r){for(n=0,i=(t=(e=a[r]).children).length;n<i;++n)t[n].geometry.dispose(),t[n].material.dispose();for(;t.length>0;)e.remove(t[0])}for(;a.length>0;)this.remove(a[0])}}])&&n(s.prototype,l),y&&n(s,y),c}(t.Group);e.OctreeHelper=c,Object.defineProperty(e,"__esModule",{value:!0})}));
